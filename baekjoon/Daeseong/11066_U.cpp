//Solution
//- 인접 페이지를 합치며 각 페이지를 한번씩 이용할 때, 거쳐온 모든 숫자의 합이 최소가 되는 값을 구하는 문제
//- 이론적 접근은 다음과 같다.
//- 1. 조건은 다음과 같다.
//- 1.1. 장은 인접한 두개의 장만 합칠 수 있다.
//- 1.2. 초기에 주어진 장은 한번씩만 결합할 수 있다.
//- 1.3. 최소합을 구한다.
//- 2. s~e 구간의 장은 두개의 그룹으로 나눌 수 있다. (s != e)
//- 2.1. [s:k], [k+1: e] (s <= k < e, [s:e]는 s부터 e까지 결합하는 최소합)
//- 2.2. 모든 k에 대해 [s:k] + [k + 1:e]를 최소로 하는 k를 구한다.
//- 3. 2.에서 구한 두 그룹에 대한 합을 구한다.
//- 3.1. 단, 장이 3개 이상 결합된 모든 상황에 대해 중복되는 장이 발생한다.
//- 3.2. 중복된 장을 제거한 경로의 모든 합을 구한다.
//- 4. 최종적으로[1:K]이 모든 장의 최소 경로 합이된다.
//- Failed 1: 중복 장을 제거하는 것을 고려하지 않아 접근이 어려웠다.
//- 1. 재귀함수에 초기 장의 페이지 수를 가지고 이동할 경우 풀이에 어려움이 있었다.
//- 1.1. 더하는 과정에서 중복해서 더해지거나,
//- 1.2. 더하지 않기위해 선택을 복잡하게 해야했다.
//- 2. 위 문제에 대한 해결방법은 다음과 같다.
//- 2.1. dp[][]를 만드는 과정에서 중간에 발생하는 '더해진 장'에서는 중복이 발생하지 않음을 알았다.
//- 2.2. 따라서, 재귀함수 내애서 초기 장수를 제외한 후, 경로값을 구한다.
//- 2.3. 구간별 장의 합은 부분합으로 구할 수 있다.
//- 2.3.1. s~e구간의 합 : sum[e] - sum[s - 1];
//- 2.4. 2.2.와 2.3을 통해 적은 연산으로 경로합을 구할 수 있었다.
//- 풀이는 다음과 같다.
//- 1. 풀이에 필요한 변수를 세팅한다.
//- 1.1. vol[] : 각 장의 페이지 수
//- 1.2. dp[][] : 인접 페이지를 최소로 합친 값
//- 1.3. sum[n] : 1~n 장의 모든 페이지 수
//- 2. expand()함수를 수행하며 dp[][] 값을 세팅한다.
//- 2.1. dp[][]에 이미 방문한 경우, dp[][]값을 리턴한다.
//- 2.1.1. e == s 일 떄, dp[s][e] = 0이다.
//- 2.1.2. e == s + 1 일 때, dp[s][e] = vol[s] + vol[e]이다.
//- 2.2. 그 외의 경우, 다음처럼 dp[s][e]를 구할 수 있다.
//- 2.2.1. k를 기준으로 순서를 유지하는 두개의 부분집합으로 나눈다. (s <= k < e)
//- 2.2.2. 부분집합의 합이 최소가 되는 값을 구한다.
//- 2.2.3. 현재까지 합쳐진 장수를 vol[]에서 찾아서 더한다.
//- 2.2.3.1. 2.1.1.에서 0으로 두었으므로 더해야한다.
//- 2.2.3.2. 이는 sum[e] - sum[s - 1]으로 구할 수 있다.
//- 2.2.3.2.1. 구간합공식 : sum[e] - sum[s - 1]
//- 2.2.4. 2.2.2.에서 구한 값과  2.2.3.의 값을 더해 dp[s][e]에 저장한다.
//- 3. dp[1][K]에 저장된 값을 출력한다.

#include <iostream>
#include <algorithm>
#include <limits.h>

using namespace std;

#define MAX_PAGE 501

int K;
int vol[MAX_PAGE];
int dp[MAX_PAGE][MAX_PAGE];
int sum[MAX_PAGE];

void init() {
    cin >> K;
    for (int y = 1; y <= K; y++) {
        for (int x = y; x <= K; x++) {
            dp[y][x] = INT_MAX;
        }
    }
    for (int k = 1; k <= K; ++k) {
        cin >> vol[k];
        sum[k] = sum[k - 1] + vol[k];
    }
}

int expand(int s, int e) {
    if (dp[s][e] != INT_MAX) return dp[s][e];
    if (s == e) return dp[s][e] = 0;
    if (s + 1 == e) return dp[s][e] = vol[s] + vol[e];

    for (int k = s; k < e; ++k) {
        dp[s][e] = min(dp[s][e], expand(s, k) + expand(k + 1, e));
    }

    return dp[s][e] += sum[e] - sum[s - 1];
}

int main() {
    int T;
    cin >> T;
    for (int t = 1; t <= T; t++) {
        init();
        cout << expand(1, K) << endl;
    }
    return 0;
}
